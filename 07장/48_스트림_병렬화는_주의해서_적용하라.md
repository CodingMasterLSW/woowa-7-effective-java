# 스트림 병렬화는 주의해서 적용하라

스트림 병렬화는 오히려 성능이 낮아지는 경우가 발생할 수 있다.
따라서 사용할 때와 사용하지 말아야 할 때를 적절히 결정해야 한다.

[참고 링크 : Baeldung](https://www.baeldung.com/java-when-to-use-parallel-stream)

## Fork-Join 프레임워크

스트림 병렬화에서는 `Fork-Join` 프레임워크를 사용하는데, (`ForkJoinExecutor`)
분할-정복 알고리즘과 비슷하게 작동한다. 먼저 데이터 소스를 분할하고, 둘을 병합하며 결과를 만들어내는 것이다.

### 공용 스레드풀

병렬 스트림에서는 기본적으로 `Fork-Join` 프레임워크의 공용 스레드풀을 사용한다.
즉, 모든 병렬 스트림에서 동일한 스레드풀을 참조한다는 것이다.

## 병렬 스트림의 성능을 결정짓는 요인

### 연산 난이도

병렬 스트림은 `Fork-Join` 프레임워크를 사용하는 만큼, 기본적으로 오버헤드가 크다.
1+1을 계산하는데 아인슈타인은 비쌀 수 있다.

### 분할 비용

오버헤드에는 분할 비용이 포함되는데, 소스가 분할하기 쉽다면 분할 비용이 줄어든다.
예를 들어, 배열을 사용하는 `ArrayList` 는 `LinkedList` 보다 분할 비용이 적다. (오버헤드가 적다.)

### 병합 비용

오버헤드에는 분할 비용이 포함되는데, 마지막 작업에 따라 병합 비용이 달라진다.
`reduce`와 같이 여러 스레드에서 병합하기 쉬운 연산의 경우 병합 비용이 줄어든다.
`collect`, `forEach` 같은 연산의 경우 병합 비용이 크다.

### 메모리 지역성

프로세서는 데이터를 가져올 때, 딱 필요한 것만 가져와서 캐싱하지 않는다.
옆에 있는 것들도 나중에 필요할 것이라고 생각해서 같이 가져와서 캐싱해둔다.

따라서 메모리 지역성이 높을 수록 캐시 미스가 줄어들고, 속도가 빨라진다.

### limit 연산

`limit` 하기 위해서는 순서 유지가 필수적이다.
또한 병렬 스트림에서 `limit`을 사용하면 지정된 요소 만큼만을 처리하기 위한 추가 연산이 사용된다.

따라서 `limit` 연산을 사용하는 순간 병렬 스트림의 성능이 저하된다.

### iterate 연산

`iterate` 연산은 무한 스트림을 생성하는 연산이다. `Stream.iterate(1, num -> num + 1)` 과 같이 사용하여, 1, 2, 3, ... 의 무한 스트림을 생성할 수 있다.

무한 스트림이니, 당연히 필요한 개수만큼을 자르는 연산이 필요하다.
`Stream.iterate(1, num -> num + 1).limit(10)` 처럼 자르거나,
`Stream.iterate(1, num < 100, num -> num + 1)` 처럼 끝내는 조건을 추가하면 된다.

결국 자르는 개념이라, `limit` 과 동일한 이유로 성능이 저하된다.

## 순차 스트림과 병렬 스트림 중 무엇을 사용해야 하는가?

*개발 중에는 순차 스트림을 기본값으로 사용해야 한다.*

성능 요구사항이 있을 때, 성능 측정을 통하여 병렬 스트림이 하나의 옵션으로 사용될 수 있다.
특히, **메모리 지역성이 높은** **분할하기 쉬운 소스**로부터 **어려운 연산**을 수행하여, **병합하기 쉬운 연산으로** 합칠수록 더 좋다.
배열이 특히 완벽하다.
